[["index.html", "FGPA for RISC-V CPU running Linux Chapter 1 前言", " FGPA for RISC-V CPU running Linux Marconi Jiang 2021-06-27 Chapter 1 前言 2021/4/22 特地到新竹參加 FB 臉友盧英嵐在新竹碼農聚會的“經濟實惠的 Linux RISC-V 開發平台, 因為報名在前五名, 還收到一片 QMTECH Altera FPGA Cyclone IV EP4CE15 Development Core Board 當贈品, 開心. 碰過的電子產品多了, 但只有早期的 PLD, 就是沒有玩過 FPGA, 這幾年, 因為機器學習/深度學習的興起, FPGA 當加速器也是個熱門話題, 有人送板子, 可以帶入門, 就開始吧. "],["fpga-hello-world-led.html", "Chapter 2 FPGA 入門 Hello World 程式 - 點亮 LED 2.1 硬體準備 2.2 安裝 intel Altera IDE Quartus 於 Ubuntu 18.04： 2.3 安裝 device : 我們在安裝 Quartus 已經安裝過了, 如果需要重新安裝時, 選擇 Quartus menu Tools - Install devices… 2.4 建立新專案 : Quartus menu 選擇 File - New Project Wizard… 一步步執行 2.5 建立新檔案 : Quartus menu 選擇 File - New… 後, 再選擇 Design Files - VHDL File 點選 OK 即可, 會出現 Vdhl1.vhd 這個檔案, 可以自行改名稱後儲存. 2.6 輸入 VHDL 檔案內容 2.7 VHDL 檔案內容建立完成後, 進入 Quartus menu 的 Processing - Start Compilation 來編譯程式, 編譯結果沒有 error, 但有不少 warning, 不妨礙. 2.8 確認腳位, Quartus menu 選取 Assignment - Pin Planner, 會出現類似下圖, 這次需要設定 Location, 我們這次用到 LED0 跟 PB (push button 按鍵的意思), 需要設定這 2 個 Node 的 location 2.9 再編譯一次, Processing - Start Compilation 2.10 燒錄: Quartus menu 選擇 Tools - Programmer 2.11 Bonus 1 : 轉檔, 從 VHDL 檔案轉成 Verilog 格式, 程式下載點 http://doolittle.icarus.com/~larry/vhd2vl/ 2.12 Bonus 2 : 後來才發現 intel 有個 youtube - How to begin a simple FGPA design 比較完整 (也比較複雜了點, 其實省略一些還是可以動作), 我的文章只有文字, 可以配合這 youtube 會更清楚", " Chapter 2 FPGA 入門 Hello World 程式 - 點亮 LED 看到這個網頁似乎是蠻簡單的, 來試試 FPGA 的 Hello World 來點亮 LED - Get Started on FPGA Programming, 照著這個一步步來 (雖然我的板子跟他的不同, 改過去應該不會太難) 2.1 硬體準備 FPGA 開發板 - QMTech Cyclone IV Core board (intel Altera Cyclone IV EP4CE15F23C8N) 的資料 QMTech 官網下載網頁 包含使用說明、線路圖 intel Altera USB Blaster : intel 在併購 Altera 後將這條 cable 改成很普通的名字, 叫做 FPGA download cable USB 轉 TTL RS232 cable 2.2 安裝 intel Altera IDE Quartus 於 Ubuntu 18.04： 原先安裝在 Windows 10, 但是 USB Blaster driver 無法更新, 就放棄, 改裝在 VM 的 Ubuntu 18.04 到 intel Altera 的官網下載 Quartus Prime Lite 免費版 其它版本 (Standard 及 Pro) 都需要付費. 也得先註冊取得帳號、密碼才能下載. 完整版的檔案非常大, 因此我只單獨下載 3 個檔案 Quartus II Software (includes Nios II EDS) ModelSim-Altera Edition (includes Starter Edition) Devices: 一定要安裝至少一個 device family, 我安裝我使用的 Cyclone IV 板子 Arria II device support : Cyclone II, Cyclone III, Cyclone IV device support (includes all variations) Intel® FPGA Software Installation and Licensing 文件 下載後, 執行 ./QuartusLiteSetup-20.1.1.720-linux.run 來安裝 安裝算簡單, 只是要注意 ModelSim 安裝的目錄 (default 是 ～/intelFPGA, 我改成 ~/intelFPGA_lite) 得和 Quartus 的安裝目錄是同一個 (~/intelFPGA_lite) 同時也安裝了 device, Cyclone IV 安裝完畢後, 執行檔位於 ./intelFPGA_lite/20.1/quartus/bin/quartus 下 $ # 執行 Quartus 程式 $ ./intelFPGA_lite/20.1/quartus/bin/quartus 2.2.1 安裝 Altera IDE Quartus 設定及遇到的問題 Quartus 一執行時就出現錯誤訊息 Failed to load module “canberra-gtk-module” 根據 Failed to load module “canberra-gtk-module”, 解決方式如下 $ sudo apt install libcanberra-gtk-module libcanberra-gtk3-module $ 執行 Processing - Start Compilation 後, 出現錯誤訊息 Altera Quartus Error (12007): Top-level design entity “……” is undefined: 根據 Stackoverflow - Altera Quartus Error (12007): Top-level design entity “……” is undefined 的第二個答案, 到 menu 的 Assignments - Settings - General - Top-Level Entity - Select Entity 去選取我的 project, 名稱是 MyProj 執行 Processing - Start Compilation 後, 出現錯誤訊息 Can’t launch ModelSim-altera simulation software: 得注意 2 點 參考 intel 文章 “Can’t lunch ModelSim-altera simulation software”, 需要確定以下設定的目錄 Tools - Options - General - EDA Tool Options - ModelSim-Alt… : 我的設定是 /home/ubuntu/intelFPGA_lite/20.1/modelsim_ase/linuxaloem 另外, 我一開始的設定 Assignment - Settings - EDA Tool Settings - EDA tools - Simulation - Run Tool Automatically - [x] Run gate-level simulation automatically after compilation 設成 enable, 把它 disable 後就可以 關於 USB Blaster 的 driver 設定: 在安裝 Quartus 之後, ‘理論上’ USB Blaster 的驅動程式應該已經安裝完成, 而且, 進入 Tools - Programmer - Hardware Setup - Hardware Settings 也可以選得到 USB-Blaster (port 2-2.2), 但是, 在 Programmer - Start 後, Progress 會出現 failed, 安裝以下設定後才能順利運作, 也才發現, 在沒安裝前, Hardware Setup 下的 Hardware Frequency 是空的, 安裝後, 會顯示 6,000,000 Hz. intel FPGA Download Cable / USB Blaster 官網的資料 , 用途不大, 現在已經不再用 USB Blaster 這名詞, 改名為 intel FPGA Download Cable USB Blaster 的 driver 設定: 參考網站文章 Using USB Blaster / USB Blaster II under Linux Driver Setup for Ubuntu : For Ubuntu 12.04/14.04/16.04 create the file /etc/udev/rules.d/51-usbblaster.rules with the following contents: 也適用 Ubuntu 18.04 $ # 建立 /etc 下的檔案需要用 sudo $ sudo vi /etc/udev/rules.d/51-usbblaster.rules # 輸入以下內容 # USB Blaster SUBSYSTEM==&quot;usb&quot;, ENV{DEVTYPE}==&quot;usb_device&quot;, ATTR{idVendor}==&quot;09fb&quot;, ATTR{idProduct}==&quot;6001&quot;, MODE=&quot;0666&quot;, NAME=&quot;bus/usb/$env{BUSNUM}/$env{DEVNUM}&quot;, RUN+=&quot;/bin/chmod 0666 %c&quot; SUBSYSTEM==&quot;usb&quot;, ENV{DEVTYPE}==&quot;usb_device&quot;, ATTR{idVendor}==&quot;09fb&quot;, ATTR{idProduct}==&quot;6002&quot;, MODE=&quot;0666&quot;, NAME=&quot;bus/usb/$env{BUSNUM}/$env{DEVNUM}&quot;, RUN+=&quot;/bin/chmod 0666 %c&quot; SUBSYSTEM==&quot;usb&quot;, ENV{DEVTYPE}==&quot;usb_device&quot;, ATTR{idVendor}==&quot;09fb&quot;, ATTR{idProduct}==&quot;6003&quot;, MODE=&quot;0666&quot;, NAME=&quot;bus/usb/$env{BUSNUM}/$env{DEVNUM}&quot;, RUN+=&quot;/bin/chmod 0666 %c&quot; 2.3 安裝 device : 我們在安裝 Quartus 已經安裝過了, 如果需要重新安裝時, 選擇 Quartus menu Tools - Install devices… 2.4 建立新專案 : Quartus menu 選擇 File - New Project Wizard… 一步步執行 Page 1: On “Directory, Name, Top-Level Entity [Page 1 of 5]”, fill in blanks as the following “What is the working directory for this project” C:/Projects/Altera/MyProj (You have to create the folder before you can select the above folder) “What is the name of this project” MyProj “What is the name of top-level design entity for this project?” MyProj Click on “Next” Page 2: On “Add Files [page 2 of 5]” Click “Next” as we’ll add files later on Page 3: On “Family &amp; Device Settings [Page 3 of 5]” In “Family:” dropdown list, select “Cyclone II” In “Available devices:” table, select “EP2C5T144C8” Click “Next” Page 4: On “EDA Tool Settings [page 4 of 5]” Click “Next” Page 5: On “Summary [page 5 of 5]” Click “Finish” 2.5 建立新檔案 : Quartus menu 選擇 File - New… 後, 再選擇 Design Files - VHDL File 點選 OK 即可, 會出現 Vdhl1.vhd 這個檔案, 可以自行改名稱後儲存. 2.6 輸入 VHDL 檔案內容 -- MyProj &quot;Hello, FPGA&quot; library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity MyProj is Port (PB : in STD_lOGIC; -- pin 144 LED0 : out STD_lOGIC; -- pin 3 LED1 : out STD_lOGIC; -- pin 7 LED2 : out STD_lOGIC); -- pin 9 end MyProj; architecture Behavioral of MyProj is begin LED0 &lt;= PB; end Behavioral; 2.7 VHDL 檔案內容建立完成後, 進入 Quartus menu 的 Processing - Start Compilation 來編譯程式, 編譯結果沒有 error, 但有不少 warning, 不妨礙. 2.8 確認腳位, Quartus menu 選取 Assignment - Pin Planner, 會出現類似下圖, 這次需要設定 Location, 我們這次用到 LED0 跟 PB (push button 按鍵的意思), 需要設定這 2 個 Node 的 location 回去看 步驟 0 的 QMTech 線路圖, 板子上的 LED0 是可以控制的, 接到 E4 腳位 (另一個 LED 是 power 的 LED 無法控制) 板子上有 3 個按鍵, SW1 / SW2 分別接到 KEY0 的 pin W13, 及 KEY1 的 pin Y13, SW3 接到 nCONFIG (待確定是不是 reset 鍵). 我們接到 W13 可以看到下圖的 Location, 我們分別設定 LED0 / PB 到 PIN_E4, PIN_W13 2.9 再編譯一次, Processing - Start Compilation 2.10 燒錄: Quartus menu 選擇 Tools - Programmer 9.1 選擇 Hardware Setup…, 確定 Available hardware items 有找到 USB-Blaster 後, 選取 Close 9.2 選擇 Add Device… 後, 選 Cyclone IV E 的 EP4CE15F23 9.3 選擇 Add File…” 後, 到 output_files 目錄下, 選取 QMTechCycloneIV_EP4CE15F23CBN.sof (或是你設定的名稱) 9.4 記得 下圖中的 Program/Configure 要打勾☑️ 9.5 接著, 按下圖的 Start, 就可以將程式上傳到 QMtech 的開發板, 按開發板上的 SW1, 就可以控制 LED0 的亮或暗 - project 成功 ！ 2.11 Bonus 1 : 轉檔, 從 VHDL 檔案轉成 Verilog 格式, 程式下載點 http://doolittle.icarus.com/~larry/vhd2vl/ # 轉檔 $ tar — extract — file vhd2vl-2.5.tar.gz $ ./vhd2vl MyProj.vhd &gt; MyProj.v # note that Verilog file’s extension is .v 2.12 Bonus 2 : 後來才發現 intel 有個 youtube - How to begin a simple FGPA design 比較完整 (也比較複雜了點, 其實省略一些還是可以動作), 我的文章只有文字, 可以配合這 youtube 會更清楚 "],["running-linux-on-fpga-vexriscv-cpu-implementation.html", "Chapter 3 Running Linux on FPGA VexRiscv CPU implementation 3.1 準備工作 3.2 軟體安裝", " Chapter 3 Running Linux on FPGA VexRiscv CPU implementation 從上一個章節的 FPGA Hello world - 點亮 LED 的範例, 直接跳到 RISC-V CPU 跑 Linux 似乎有點快, 不過, 有時候, 動手做比了解原理更簡單, 這實驗看起來不容易, 做起來還真的不難, 比我想像的要簡單很多. (而且, 全部加起來的費用不到 1,000 台幣) 3.1 準備工作 硬體說明 * The FPGA hardware for this project is based on QMTech Altera Cyclone IV EP4CE15F23CBN core board, Mac 硬碟 * where to buy * intel Altera USB Blaster : intel 在併購 Altera 後將這條 cable 改成很普通的名字, 叫做 FPGA download cable * USB 轉 TTL RS232 cable * 線路圖 軟體說明 * 基於 linux-on-litex-vexriscv 的步驟 * 需要安裝其它套件 * LiteX 是基礎 LiteX - build your hardware, easily * pythondata-cpu-vexriscv * SpinalHDL (用於產生 VHDL/Verilog 檔案):需要安裝 Java JDK 及 Scala SBT * 安裝 Altera IDE Quartus (見上節 §2.2 安裝 intel Altera IDE Quartus ) * 安裝 PIP3 : linux-on-litex-vexriscv 使用 Python3, Python3 已經是 Ubuntu 18.04 標配, 如果還沒有安裝 PIP3, 記得要安裝. (如果不小心下錯指令跟版本到 Python 或 PIP, 程式會報錯, 需要使用 &gt;= Python 3.5, 再安裝 PIP3 即可) $ sudo apt install python3-pip $ 3.2 軟體安裝 3.2.1 軟體介紹 linux-on-litex-vexriscv 開宗明義就提到結合 Spinal HDL 跟 Migen 來 deploy 到各種不同的 FPGA 開發板來實現, 以 VexRiscv CPU (Spinal HDL 撰寫) 為中心, 用 LiteX (基於 Migen Python DSL) 建立 SOC. 3.2.2 適用開發板 適用多種不同的 FPGA 品牌跟開發板, 雖然規格跟功能各有不同, 但都適用同一套安裝程序. 我手上的 QMTech EP4CE15F23CBN Altera Cyclone IV 規格是最低的, 也可以運作. 3.2.3 預先安裝 $ sudo apt install build-essential device-tree-compiler wget git python3-setuptools $ git clone https://github.com/litex-hub/linux-on-litex-vexriscv $ cd linux-on-litex-vexriscv $ 3.2.4 Pre-built Bitstreams 跟 Linux/OpenSBI images 下載image, 需要下載至 linux-on-litex-vexriscv/images 目錄下 * inux_2020_12_30.zip (5.10-stable)： 包含 “Image,” “rootfs.cpio” * opensbi_2020_12_15.zip ： 包含 “opensbi.bin” 至於 .dtb, 會在之後產生 QMTech_EP4CE15F 所需的 rv32.dtb 3.2.5 安裝 LiteX 到 Enjoy-digital/litex 有完整的安裝過程及模擬, 也說明如下 3.2.5.1 安裝 Migen/LiteX 及 LiteX’s 核心: $ wget https://raw.githubusercontent.com/enjoy-digital/litex/master/litex_setup.py $ chmod +x litex_setup.py # $ ./litex_setup.py init install --user (--user to install to user directory) # 會安裝在 ../ 目錄下 $ ./litex_setup.py init install --user # 會安裝在 ~ 目錄下 會在 ~ 目錄下安裝 LiteX 所需的許多檔案目錄 3.2.5.2 更新 (第一次安裝可省略) 後續如果有需要更新 github repo 的內容, 利用以下指令 $ cd linux-on-litex-vexriscv/ $ ./litex_setup.py update 3.2.5.3 安裝 RISC-V toolchain (如果想要的話 test/create a SoC with a CPU): $ cd linux-on-litex-vexriscv/ $ ./litex_setup.py gcc 3.2.5.4 Build 開發板 到上個步驟 litex_setup.py 建立的目錄下的子目錄 litex-boards/litex_boards/targets 去執行 # 以我的例子 litex_setup.py 目錄建立在 ～ $ cd ~ $ cd litex-boards/litex_boards/targets $ ./qmtech_ep4ce15.py $ 3.2.5.5 安裝及在筆電上測試 LiteX (我們可以安裝, 在筆電上模擬測試) $ sudo apt install libevent-dev libjson-c-dev verilator $ lxsim --cpu-type=vexriscv 進入 litex 環境後, 出現以下螢幕, 可以輸入 help 來看可用的指令有哪些, 用 ctrl-c 結束 litex, 回到 Ubuntu 環境 3.2.6 安裝 RISC-V toolchain 回到 linux-on-litex-vexriscv 的步驟, 接下去安裝 $ wget https://static.dev.sifive.com/dev-tools/riscv64-unknown-elf-gcc-8.1.0-2019.01.0-x86_64-linux-ubuntu14.tar.gz $ tar -xvf riscv64-unknown-elf-gcc-8.1.0-2019.01.0-x86_64-linux-ubuntu14.tar.gz $ export PATH=$PATH:$PWD/riscv64-unknown-elf-gcc-8.1.0-2019.01.0-x86_64-linux-ubuntu14/bin/ $ 3.2.7 安裝 OpenOCD (做硬體測試時需要, 所以我們需要安裝) $ sudo apt install libtool automake pkg-config libusb-1.0-0-dev $ git clone https://github.com/ntfreak/openocd.git $ cd openocd $ ./bootstrap $ ./configure --enable-ftdi $ make $ sudo make install $ 3.2.8 執行 LiteX 模擬 3.2.8.1 安裝 SpinalHDL 需要安裝 Java SDK 跟 Scala 的 SBT SpinalHDL - get started $ sudo apt-get install openjdk-8-jdk $ sudo apt-get install scala $ echo &quot;deb https://dl.bintray.com/sbt/debian /&quot; | sudo tee -a /etc/apt/sources.list.d/sbt.list $ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 642AC823 $ sudo apt-get update $ sudo apt-get install sbt $ git clone https://github.com/SpinalHDL/SpinalTemplateSbt.git SpinalTemplateSbt $ cd SpinalTemplateSbt $ sbt run # select &quot;mylib.MyTopLevelVhdl&quot; in the menu $ ls MyTopLevel.vhd 3.2.8.2 執行模擬 $ cd /linux-on-litex-vexriscv/ $ ./sim.py 3.2.9 在硬體上測試 3.2.9.1 Build FPGA bitstream 我將部份的 log po 上, 完整 log, 請看 litex_lxterm.log # github 上原始指令 # $ ./make.py --board=XXYY --cpu-count=X --build # 配合 FPGA 開發板修改後的指令如下 ubuntu@ubuntu:~/linux-on-litex-vexriscv$ ./make.py --board=qmtech_ep4ce15 --cpu-count=1 --build INFO:SoC: __ _ __ _ __ INFO:SoC: / / (_) /____ | |/_/ INFO:SoC: / /__/ / __/ -_)&gt; &lt; INFO:SoC: /____/_/\\__/\\__/_/|_| INFO:SoC: Build your hardware, easily! INFO:SoC:-------------------------------------------------------------------------------- INFO:SoC:Creating SoC... (2021-06-23 21:55:13) INFO:SoC:-------------------------------------------------------------------------------- INFO:SoC:FPGA device : EP4CE15F23C8. INFO:SoC:System clock: 50.00MHz. INFO:SoCBusHandler:Creating Bus Handler... INFO:SoCBusHandler:32-bit wishbone Bus, 4.0GiB Address Space. INFO:SoCBusHandler:Adding reserved Bus Regions... INFO:SoCBusHandler:Bus Handler created. INFO:SoCCSRHandler:Creating CSR Handler... INFO:SoCCSRHandler:32-bit CSR Bus, 32-bit Aligned, 16.0KiB Address Space, 2048B Paging, big Ordering (Up to 32 Locations). INFO:SoCCSRHandler:Adding reserved CSRs... INFO:SoCCSRHandler:ctrl CSR added at Location 0. INFO:SoCCSRHandler:uart CSR added at Location 2. INFO:SoCCSRHandler:timer0 CSR added at Location 3. INFO:SoCCSRHandler:CSR Handler created. INFO:SoCIRQHandler:Creating IRQ Handler... INFO:SoCIRQHandler:IRQ Handler (up to 32 Locations). INFO:SoCIRQHandler:Adding reserved IRQs... INFO:SoCIRQHandler:IRQ Handler created. INFO:SoC:-------------------------------------------------------------------------------- INFO:SoC:Initial SoC: INFO:SoC:-------------------------------------------------------------------------------- INFO:SoC:32-bit wishbone Bus, 4.0GiB Address Space. INFO:SoC:32-bit CSR Bus, 32-bit Aligned, 16.0KiB Address Space, 2048B Paging, big Ordering (Up to 32 Locations). CSR Locations: (3) - ctrl : 0 - uart : 2 - timer0 : 3 INFO:SoC:IRQ Handler (up to 32 Locations). INFO:SoC:-------------------------------------------------------------------------------- ...... Info: Quartus Prime Timing Analyzer was successful. 0 errors, 16 warnings Info: Peak virtual memory: 592 megabytes Info: Processing ended: Wed Jun 23 21:57:07 2021 Info: Elapsed time: 00:00:07 Info: Total CPU time (on all processors): 00:00:08 Info: ******************************************************************* Info: Running Quartus Prime Convert_programming_file Info: Version 20.1.1 Build 720 11/11/2020 SJ Lite Edition Info: Copyright (C) 2020 Intel Corporation. All rights reserved. Info: Your use of Intel Corporation&#39;s design tools, logic functions Info: and other software and tools, and any partner logic Info: functions, and any output files from any of the foregoing Info: (including device programming or simulation files), and any Info: associated documentation or information are expressly subject Info: to the terms and conditions of the Intel Program License Info: Subscription Agreement, the Intel Quartus Prime License Agreement, Info: the Intel FPGA IP License Agreement, or other applicable license Info: agreement, including, without limitation, that your use is for Info: the sole purpose of programming logic devices manufactured by Info: Intel and sold by Intel or its authorized distributors. Please Info: refer to the applicable agreement for further details, at Info: https://fpgasoftware.intel.com/eula. Info: Processing started: Wed Jun 23 21:57:07 2021 Info: Command: quartus_cpf -c qmtech_ep4ce15.sof qmtech_ep4ce15.rbf Info: Quartus Prime Convert_programming_file was successful. 0 errors, 0 warnings Info: Peak virtual memory: 323 megabytes Info: Processing ended: Wed Jun 23 21:57:07 2021 Info: Elapsed time: 00:00:00 Info: Total CPU time (on all processors): 00:00:00 –board=XXYY 裡面的 XXYY, 可以參照 (github) linux-on-litex-vexriscv/make.py 裡面的 supported_boards 冒號左邊的定義 supported_boards = { # Xilinx &quot;acorn_cle_215&quot;: AcornCLE215, &quot;arty&quot;: Arty, &quot;arty_a7&quot;: ArtyA7, &quot;arty_s7&quot;: ArtyS7, &quot;netv2&quot;: NeTV2, &quot;genesys2&quot;: Genesys2, &quot;kc705&quot;: KC705, &quot;kcu105&quot;: KCU105, &quot;zcu104&quot;: ZCU104, &quot;nexys4ddr&quot;: Nexys4DDR, &quot;nexys_video&quot;: NexysVideo, &quot;minispartan6&quot;: MiniSpartan6, &quot;pipistrello&quot;: Pipistrello, &quot;xcu1525&quot;: XCU1525, &quot;qmtech_wukong&quot;: Qmtech_WuKong, &quot;sds1104xe&quot;: SDS1104XE, # Lattice &quot;versa_ecp5&quot;: VersaECP5, &quot;ulx3s&quot;: ULX3S, &quot;hadbadge&quot;: HADBadge, &quot;orangecrab&quot;: OrangeCrab, &quot;camlink_4k&quot;: CamLink4K, &quot;trellisboard&quot;: TrellisBoard, &quot;ecpix5&quot;: ECPIX5, &quot;colorlight_i5&quot;: Colorlight_i5, # Altera/Intel &quot;de0nano&quot;: De0Nano, &quot;de10nano&quot;: De10Nano, &quot;qmtech_ep4ce15&quot;: Qmtech_EP4CE15, } 3.2.9.2 Load FPGA bitstream 上傳 bitstream 到 FPGA 板, 將部份的 log po 於下方, 完整 log, 請看 litex_lxterm.log ubuntu@ubuntu:~/linux-on-litex-vexriscv$ ./make.py --board=qmtech_ep4ce15 --cpu-count=1 --load INFO:SoC: __ _ __ _ __ INFO:SoC: / / (_) /____ | |/_/ INFO:SoC: / /__/ / __/ -_)&gt; &lt; INFO:SoC: /____/_/\\__/\\__/_/|_| INFO:SoC: Build your hardware, easily! INFO:SoC:-------------------------------------------------------------------------------- INFO:SoC:Creating SoC... (2021-06-23 22:03:34) INFO:SoC:-------------------------------------------------------------------------------- INFO:SoC:FPGA device : EP4CE15F23C8. INFO:SoC:System clock: 50.00MHz. ....... Info: Command: quartus_pgm -m jtag -c USB-Blaster -o p;/home/ubuntu/linux-on-litex-vexriscv/build/qmtech_ep4ce15/gateware/qmtech_ep4ce15.sof@1 Info (213045): Using programming cable &quot;USB-Blaster [2-2.1]&quot; Info (213011): Using programming file /home/ubuntu/linux-on-litex-vexriscv/build/qmtech_ep4ce15/gateware/qmtech_ep4ce15.sof with checksum 0x0091D628 for device EP4CE15F23@1 Info (209060): Started Programmer operation at Wed Jun 23 22:03:39 2021 Info (209016): Configuring device index 1 Info (209017): Device 1 contains JTAG ID code 0x020F20DD Info (209007): Configuration succeeded -- 1 device(s) configured Info (209011): Successfully performed operation(s) Info (209061): Ended Programmer operation at Wed Jun 23 22:03:40 2021 Info: Quartus Prime Programmer was successful. 0 errors, 0 warnings Info: Peak virtual memory: 329 megabytes Info: Processing ended: Wed Jun 23 22:03:40 2021 Info: Elapsed time: 00:00:04 Info: Total CPU time (on all processors): 00:00:00 $ 3.2.9.3 Load Linux images 透過 Serial port 到 FPGA 板 $ lxterm --images=images/boot.json /dev/ttyUSBX --speed=1e6 $ 執行 lxterm 程式後, 再去按下 QMTech FPGA 板子的 RESET 按鍵, 就可以順利從 serial port 下載 Linux images (這是原版漏的內容, 花了半天的時間在空等, 也沒有錯誤訊息, 因為 FPGA 板子比較早開機, 筆電的 images 比較晚送到, 就彼此在等對方. reset FPGA 板子後, 重新開始 negotiation 的 protocol, 馬上開始上傳 images) 3.2.10 Option 選項 - Configure/Use the peripherals 參考 HOWTO 文件來 configure 已及 Linux 週邊設定. 3.2.10.1 創建 Linux binaries (optional) : $ git clone http://github.com/buildroot/buildroot $ cd buildroot $ make BR2_EXTERNAL=../linux-on-litex-vexriscv/buildroot/ litex_vexriscv_defconfig $ make 產生的 binaries 位於目錄 output/images/ 下 3.2.10.2 創建 OpenSBI binary (optional) : $ git clone https://github.com/litex-hub/opensbi --branch 0.8-linux-on-litex-vexriscv $ cd opensbi $ make CROSS_COMPILE=riscv-none-embed- PLATFORM=litex/vexriscv $ 產生的 binary 位於目錄 build/platform/litex/vexriscv/firmware/fw_jump.bin 3.2.10.3 創建 VexRiscv Linux variant (optional) ：我跳過這部分 If the VexRiscv configuration you ask isn’t already generated, you will need to install java and SBT on your machine to enable their local on demande generation. To install java and SBT see Install VexRiscv requirements: https://github.com/enjoy-digital/VexRiscv-verilog#requirements 3.2.10.4 Udev rules (optional) ： 我跳過這部分 Not needed but can make loading/flashing bitstreams easier: $ git clone https://github.com/litex-hub/litex-buildenv-udev $ cd litex-buildenv-udev $ make install $ make reload "],["references-.html", "References 參考文獻", " References 參考文獻 參考資料 1. 說明文件 - "],["appendixa.html", "A Appendix A", " A Appendix A "],["appendixb.html", "B Appendix B", " B Appendix B "]]
